<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="de" lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<title>Benutzeranleitung für DBUtils</title>
<link rel="stylesheet" href="doc.css" type="text/css" />
</head>
<body class="with-toc">
<main id="benutzeranleitung-fur-dbutils">
<h1 class="title">Benutzeranleitung für DBUtils</h1>
<dl class="docinfo simple">
<dt class="version">Version<span class="colon">:</span></dt>
<dd class="version">3.0.3</dd>
<dt class="translations">Translations<span class="colon">:</span></dt>
<dd class="translations"><p><a class="reference external" href="main.html">English</a> | German</p>
</dd>
</dl>
<nav class="contents" id="inhalt" role="doc-toc">
<p class="topic-title">Inhalt</p>
<ul class="simple">
<li><p><a class="reference internal" href="#zusammenfassung" id="toc-entry-1">Zusammenfassung</a></p></li>
<li><p><a class="reference internal" href="#module" id="toc-entry-2">Module</a></p></li>
<li><p><a class="reference internal" href="#download" id="toc-entry-3">Download</a></p></li>
<li><p><a class="reference internal" href="#installation" id="toc-entry-4">Installation</a></p>
<ul>
<li><p><a class="reference internal" href="#installation-1" id="toc-entry-5">Installation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#anforderungen" id="toc-entry-6">Anforderungen</a></p></li>
<li><p><a class="reference internal" href="#funktionalitat" id="toc-entry-7">Funktionalität</a></p>
<ul>
<li><p><a class="reference internal" href="#simplepooleddb-simple-pooled-db" id="toc-entry-8">SimplePooledDB (simple_pooled_db)</a></p></li>
<li><p><a class="reference internal" href="#steadydbconnection-steady-db" id="toc-entry-9">SteadyDBConnection (steady_db)</a></p></li>
<li><p><a class="reference internal" href="#persistentdb-persistent-db" id="toc-entry-10">PersistentDB (persistent_db)</a></p></li>
<li><p><a class="reference internal" href="#pooleddb-pooled-db" id="toc-entry-11">PooledDB (pooled_db)</a></p></li>
<li><p><a class="reference internal" href="#die-qual-der-wahl" id="toc-entry-12">Die Qual der Wahl</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#benutzung" id="toc-entry-13">Benutzung</a></p>
<ul>
<li><p><a class="reference internal" href="#persistentdb-persistent-db-1" id="toc-entry-14">PersistentDB (persistent_db)</a></p></li>
<li><p><a class="reference internal" href="#pooleddb-pooled-db-1" id="toc-entry-15">PooledDB (pooled_db)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#besonderheiten-bei-der-benutzung" id="toc-entry-16">Besonderheiten bei der Benutzung</a></p></li>
<li><p><a class="reference internal" href="#anmerkungen" id="toc-entry-17">Anmerkungen</a></p></li>
<li><p><a class="reference internal" href="#zukunft" id="toc-entry-18">Zukunft</a></p></li>
<li><p><a class="reference internal" href="#fehlermeldungen-und-feedback" id="toc-entry-19">Fehlermeldungen und Feedback</a></p></li>
<li><p><a class="reference internal" href="#links" id="toc-entry-20">Links</a></p></li>
<li><p><a class="reference internal" href="#autoren" id="toc-entry-21">Autoren</a></p></li>
<li><p><a class="reference internal" href="#copyright-und-lizenz" id="toc-entry-22">Copyright und Lizenz</a></p></li>
</ul>
</nav>
<section id="zusammenfassung">
<h2>Zusammenfassung</h2>
<p><a class="reference external" href="https://github.com/WebwareForPython/DBUtils">DBUtils</a> ist eine Sammlung von Python-Modulen, mit deren Hilfe man in <a class="reference external" href="https://www.python.org">Python</a>
geschriebene Multithread-Anwendungen auf sichere und effiziente Weise an
Datenbanken anbinden kann.</p>
<p>DBUtils wurde ursprünglich speziell für <a class="reference external" href="https://webwareforpython.github.io/w4py/">Webware for Python</a> als Anwendung
und <a class="reference external" href="https://www.pygresql.org/">PyGreSQL</a> als <a class="reference external" href="https://www.postgresql.org/">PostgreSQL</a>-Datenbankadapter entwickelt,
kann aber inzwischen für beliebige Python-Anwendungen und beliebige
auf <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">DB-API 2</a> beruhende Python-Datenbankadapter verwendet werden.</p>
</section>
<section id="module">
<h2>Module</h2>
<p>DBUtils ist als Python-Package realisiert worden, das aus zwei verschiedenen
Gruppen von Modulen besteht: Einer Gruppe zur Verwendung mit beliebigen
DB-API-2-Datenbankadaptern, und einer Gruppe zur Verwendung mit dem klassischen
PyGreSQL-Datenbankadapter-Modul.</p>
<table>
<thead>
<tr><th class="head" colspan="2"><p>Allgemeine Variante für beliebige DB-API-2-Adapter</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>steady_db</p></td>
<td><p>Gehärtete DB-API-2-Datenbankverbindungen</p></td>
</tr>
<tr><td><p>pooled_db</p></td>
<td><p>Pooling für DB-API-2-Datenbankverbindungen</p></td>
</tr>
<tr><td><p>persistent_db</p></td>
<td><p>Persistente DB-API-2-Datenbankverbindungen</p></td>
</tr>
<tr><td><p>simple_pooled_db</p></td>
<td><p>Einfaches Pooling für DB-API 2</p></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr><th class="head" colspan="2"><p>Variante speziell für den klassischen PyGreSQL-Adapter</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>steady_pg</p></td>
<td><p>Gehärtete klassische PyGreSQL-Verbindungen</p></td>
</tr>
<tr><td><p>pooled_pg</p></td>
<td><p>Pooling für klassische PyGreSQL-Verbindungen</p></td>
</tr>
<tr><td><p>persistent_pg</p></td>
<td><p>Persistente klassische PyGreSQL-Verbindungen</p></td>
</tr>
<tr><td><p>simple_pooled_pg</p></td>
<td><p>Einfaches Pooling für klassisches PyGreSQL</p></td>
</tr>
</tbody>
</table>
<p>Die Abhängigkeiten der Module in der Variante für beliebige DB-API-2-Adapter
sind im folgenden Diagramm dargestellt:</p>
<img alt="dependencies_db.png" src="dependencies_db.png" />
<p>Die Abhängigkeiten der Module in der Variante für den klassischen
PyGreSQL-Adapter sehen ähnlich aus:</p>
<img alt="depdependencies_pg.png" src="depdependencies_pg.png" />
</section>
<section id="download">
<h2>Download</h2>
<p>Die aktuelle Version von DBUtils kann vom Python Package Index
heruntergeladen werden:</p>
<pre class="literal-block">https://pypi.python.org/pypi/DBUtils</pre>
<p>Das Source-Code-Repository befindet sich hier auf GitHub:</p>
<pre class="literal-block">https://github.com/WebwareForPython/DBUtils</pre>
</section>
<section id="installation">
<h2>Installation</h2>
<section id="installation-1">
<h3>Installation</h3>
<p>Das Paket kann auf die übliche Weise installiert werden:</p>
<pre class="literal-block">python setup.py install</pre>
<p>Noch einfacher ist, das Paket in einem Schritt mit <a class="reference external" href="https://pip.pypa.io/">pip</a> automatisch
herunterzuladen und zu installieren:</p>
<pre class="literal-block">pip install DBUtils</pre>
</section>
</section>
<section id="anforderungen">
<h2>Anforderungen</h2>
<p>DBUtils unterstützt die <a class="reference external" href="https://www.python.org">Python</a> Versionen 3.6 bis 3.11.</p>
<p>Die Module in der Variante für klassisches PyGreSQL benötigen <a class="reference external" href="https://www.pygresql.org/">PyGreSQL</a>
Version 4.0 oder höher, während die Module in der allgemeinen Variante
für DB-API 2 mit jedem beliebigen Python-Datenbankadapter-Modul zusammenarbeiten,
das auf <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">DB-API 2</a> basiert.</p>
</section>
<section id="funktionalitat">
<h2>Funktionalität</h2>
<p>Dieser Abschnitt verwendet nur die Bezeichnungen der DB-API-2-Variante, aber
Entsprechendes gilt auch für die PyGreSQL-Variante.</p>
<p>DBUtils installiert sich als Paket <span class="docutils literal">dbutils</span>, das alle hier beschriebenen
Module enthält. Jedes dieser Modul enthält im Wesentlichen eine Klasse, die
einen analogen Namen trägt und die jeweilige Funktionalität bereitstellt.
So enthält z.B. das Modul <span class="docutils literal">dbutils.pooled_db</span> die Klasse <span class="docutils literal">PooledDB</span>.</p>
<section id="simplepooleddb-simple-pooled-db">
<h3>SimplePooledDB (simple_pooled_db)</h3>
<p>Die Klasse <span class="docutils literal">SimplePooledDB</span> in <span class="docutils literal">dbutils.simple_pooled_db</span> ist eine sehr
elementare Referenz-Implementierung eines Pools von Datenbankverbindungen.
Hiermit ist ein Vorratsspeicher an Datenbankverbindungen gemeint, aus dem sich
die Python-Anwendung bedienen kann. Diese Implementierung ist weit weniger
ausgefeilt als das eigentliche <span class="docutils literal">pooled_db</span>-Modul und stellt insbesondere
keine Ausfallsicherung zur Verfügung. <span class="docutils literal">dbutils.simple_pooled_db</span> ist im
Wesentlichen identisch mit dem zu Webware for Python gehörenden Modul
<span class="docutils literal">MiscUtils.DBPool</span>. Es ist eher zur Verdeutlichung des Konzepts gedacht,
als zum Einsatz im produktiven Betrieb.</p>
</section>
<section id="steadydbconnection-steady-db">
<h3>SteadyDBConnection (steady_db)</h3>
<p>Die Klasse <span class="docutils literal">SteadyDBConnection</span> im Modul <span class="docutils literal">dbutils.steady_db</span> stellt
&quot;gehärtete&quot; Datenbankverbindungen bereit, denen gewöhnlichen Verbindungen
eines DB-API-2-Datenbankadapters zugrunde liegen. Eine &quot;gehärtete&quot; Verbindung
wird bei Zugriff automatisch, ohne dass die Anwendung dies bemerkt, wieder
geöffnet, wenn sie geschlossen wurde, die Datenbankverbindung unterbrochen
wurde, oder wenn sie öfter als ein optionales Limit genutzt wurde.</p>
<p>Ein typisches Beispiel wo dies benötig wird, ist, wenn die Datenbank neu
gestartet wurde, während Ihre Anwendung immer noch läuft und Verbindungen
zur Datenbank offen hat, oder wenn Ihre Anwendung auf eine entfernte Datenbank
über ein Netzwerk zugreift, das durch eine Firewall geschützt ist, und die
Firewall neu gestartet wurde und dabei ihren Verbindungsstatus verloren hat.</p>
<p>Normalerweise benutzen Sie das <span class="docutils literal">steady_db</span>-Modul nicht direkt; es wird aber
von den beiden nächsten Modulen benötigt, <span class="docutils literal">persistent_db</span> und <span class="docutils literal">pooled_db</span>.</p>
</section>
<section id="persistentdb-persistent-db">
<h3>PersistentDB (persistent_db)</h3>
<p>Die Klasse <span class="docutils literal">PersistentDB</span> im Modul <span class="docutils literal">dbutils.persistent_db</span> stellt
gehärtete,  thread-affine, persistente Datenbankverbindungen zur Verfügung,
unter Benutzung eines beliebigen DB-API-2-Datenbankadapters. Mit &quot;thread-affin&quot;
und &quot;persistent&quot; ist hierbei gemeint, dass die einzelnen Datenbankverbindungen
den jeweiligen Threads fest zugeordnet bleiben und während der Laufzeit des
Threads nicht geschlossen werden.</p>
<p>Das folgende Diagramm zeigt die beteiligten Verbindungsschichten, wenn Sie
<span class="docutils literal">persistent_db</span>-Datenbankverbindungen einsetzen:</p>
<img alt="persistent.png" src="persistent.png" />
<p>Immer wenn ein Thread eine Datenbankverbindung zum ersten Mal öffnet, wird
eine neue Datenbankverbindung geöffnet, die von da an immer wieder für genau
diesen Thread verwendet wird. Wenn der Thread die Datenbankverbindung schließt,
wird sie trotzdem weiter offen gehalten, damit beim nächsten Mal, wenn der
gleiche Thread wieder eine Datenbankverbindung anfordert, diese gleiche bereits
geöffnete Datenbankverbindung wieder verwendet werden kann. Die Verbindung wird
automatisch geschlossen, wenn der Thread beendet wird.</p>
<p>Kurz gesagt versucht <span class="docutils literal">persistent_db</span> Datenbankverbindungen wiederzuverwerten,
um die Gesamteffizienz der Datenbankzugriffe Ihrer Multithread-Anwendungen zu
steigern, aber es wird dabei sichergestellt, dass verschiedene Threads niemals
die gleiche Verbindung benutzen.</p>
<p>Daher arbeitet <span class="docutils literal">persistent_db</span> sogar dann problemlos, wenn der zugrunde
liegende DB-API-2-Datenbankadapter nicht thread-sicher auf der Verbindungsebene
ist, oder wenn parallele Threads Parameter der Datenbank-Sitzung verändern
oder Transaktionen mit mehreren SQL-Befehlen durchführen.</p>
</section>
<section id="pooleddb-pooled-db">
<h3>PooledDB (pooled_db)</h3>
<p>Die Klasse <span class="docutils literal">PooledDB</span> im Modul <span class="docutils literal">dbutils.pooled_db</span> stellt, unter Benutzung
eines beliebigen DB-API-2-Datenbankadapters, einen Pool von gehärteten,
thread-sicheren Datenbankverbindungen zur Verfügung, die automatisch, ohne dass
die Anwendung dies bemerkt, wiederverwendet werden.</p>
<p>Das folgende Diagramm zeigt die beteiligten Verbindungsschichten, wenn Sie
<span class="docutils literal">pooled_db</span>-Datenbankverbindungen einsetzen:</p>
<img alt="pooled.png" src="pooled.png" />
<p>Wie im Diagramm angedeutet, kann <span class="docutils literal">pooled_db</span> geöffnete Datenbankverbindungen
den verschiedenen Threads beliebig zuteilen. Dies geschieht standardmäßig, wenn
Sie den Verbindungspool mit einem positiven Wert für <span class="docutils literal">maxshared</span> einrichten
und der zugrunde liegende DB-API-2-Datenbankadapter auf der Verbindungsebene
thread-sicher ist, aber sie können auch dedizierte Datenbankverbindungen
anfordern, die nicht von anderen Threads verwendet werden sollen. Neben dem
Pool gemeinsam genutzter Datenbankverbindungen (&quot;shared pool&quot;) können Sie auch
einen Pool von mindestens <span class="docutils literal">mincached</span> und höchstens <span class="docutils literal">maxcached</span> inaktiven
Verbindungen auf Vorrat einrichten (&quot;idle pool&quot;), aus dem immer dann geschöpft
wird, wenn ein Thread eine dedizierte Datenbankverbindung anfordert, oder wenn
der Pool gemeinsam genutzter Datenbankverbindungen noch nicht voll ist.
Wenn ein Thread eine Datenbankverbindung schließt, die auch von keinem anderen
Thread mehr benutzt wird, wird sie an den Vorratsspeicher inaktiver
Datenbankverbindungen zurückgegeben, damit sie wiederverwertet werden kann.</p>
<p>Wenn der zugrunde liegende DB-API-Datenbankadapter nicht thread-sicher ist,
werden Thread-Locks verwendet, um sicherzustellen, dass die
<span class="docutils literal">pooled_db</span>-Verbindungen dennoch thread-sicher sind. Sie brauchen sich also
hierum keine Sorgen zu machen, aber Sie sollten darauf achten, dedizierte
Datenbankverbindungen zu verwenden, sobald Sie Parameter der Datenbanksitzung
verändern oder Transaktionen mit mehreren SQL-Befehlen ausführen.</p>
</section>
<section id="die-qual-der-wahl">
<h3>Die Qual der Wahl</h3>
<p>Sowohl <span class="docutils literal">persistent_db</span> als auch <span class="docutils literal">pooled_db</span> dienen dem gleichen Zweck,
nämlich die Effizienz des Datenbankzugriffs durch Wiederverwendung von
Datenbankverbindungen zu steigern, und dabei gleichzeitig die Stabilität
zu gewährleisten, selbst wenn die Datenbankverbindung unterbrochen wird.</p>
<p>Welches der beiden Module sollte also verwendet werden? Nach den obigen
Erklärungen ist es klar, dass <span class="docutils literal">persistent_db</span> dann sinnvoller ist, wenn
Ihre Anwendung eine gleich bleibende Anzahl Threads verwendet, die häufig
auf die Datenbank zugreifen. In diesem Fall werden Sie ungefähr die gleiche
Anzahl geöffneter Datenbankverbindungen erhalten. Wenn jedoch Ihre Anwendung
häufig Threads beendet und neu startet, dann ist <span class="docutils literal">pooled_db</span> die bessere
Lösung, die auch mehr Möglichkeiten zur Feineinstellung zur Verbesserung
der Effizienz erlaubt, insbesondere bei Verwendung eines thread-sicheren
DB-API-2-Datenbankadapters.</p>
<p>Da die Schnittstellen beider Module sehr ähnlich sind, können Sie recht einfach
von einem Modul zum anderen wechseln und austesten, welches geeigneter ist.</p>
</section>
</section>
<section id="benutzung">
<h2>Benutzung</h2>
<p>Die Benutzung aller Module ist zwar recht ähnlich, aber es gibt vor allem bei
der Initialisierung auch einige Unterschiede, sowohl zwischen den &quot;Pooled&quot;-
und den &quot;Persistent&quot;-Varianten, als auch zwischen den DB-API-2- und den
PyGreSQL-Varianten.</p>
<p>Wir werden hier nur auf das <span class="docutils literal">persistent_db</span>-Modul und das etwas kompliziertere
<span class="docutils literal">pooled_db</span>-Modul eingehen. Einzelheiten zu den anderen Modulen finden Sie
in deren Docstrings. Unter Verwendung der Python-Interpreter-Konsole können Sie
sich die Dokumentation des <span class="docutils literal">pooled_db</span>-Moduls wie folgt anzeigen lassen (dies
funktioniert entsprechend auch mit den anderen Modulen):</p>
<pre class="literal-block">help(pooled_db)</pre>
<section id="persistentdb-persistent-db-1">
<h3>PersistentDB (persistent_db)</h3>
<p>Wenn Sie das <span class="docutils literal">persistent_db</span>-Modul einsetzen möchten, müssen Sie zuerst einen
Generator für die von Ihnen gewünschte Art von Datenbankverbindungen einrichten,
indem Sie eine Instanz der Klasse <span class="docutils literal">persistent_db</span> erzeugen, wobei Sie folgende
Parameter angeben müssen:</p>
<ul>
<li><p><span class="docutils literal">creator</span>: entweder eine Funktion, die neue DB-API-2-Verbindungen
erzeugt, oder ein DB-API-2-Datenbankadapter-Modul</p></li>
<li><p><span class="docutils literal">maxusage</span>: Obergrenze dafür, wie oft eine einzelne Verbindung
wiederverwendet werden darf (der Standardwert <span class="docutils literal">0</span> oder <span class="docutils literal">None</span>
bedeutet unbegrenzte Wiederverwendung)</p>
<p>Sobald diese Obergrenze erreicht wird, wird die Verbindung zurückgesetzt.</p>
</li>
<li><p><span class="docutils literal">setsession</span>: eine optionale Liste von SQL-Befehlen zur Initialisierung
der Datenbanksitzung, z.B. <span class="docutils literal">[&quot;set datestyle to german&quot;, <span class="pre">...]</span></span></p></li>
<li><p><span class="docutils literal">failures</span>: eine optionale Exception-Klasse oder ein Tupel von Exceptions,
bei denen die Ausfallsicherung zum Tragen kommen soll, falls die Vorgabe
(OperationalError, InterfaceError, InternalError) für das verwendete
Datenbankadapter-Modul nicht geeignet sein sollte</p></li>
<li><p><span class="docutils literal">ping</span>: mit diesem Parameter kann eingestellt werden, wann Verbindungen
mit der <span class="docutils literal">ping()</span>-Methode geprüft werden, falls eine solche vorhanden ist
(<span class="docutils literal">0</span> = <span class="docutils literal">None</span> = nie, <span class="docutils literal">1</span> = Standardwert = immer wenn neu angefragt,
<span class="docutils literal">2</span> = vor Erzeugen eines Cursors, <span class="docutils literal">4</span> = vor dem Ausführen von Abfragen,
<span class="docutils literal">7</span> = immer, und alle Bitkombinationen dieser Werte)</p></li>
<li><p><span class="docutils literal">closeable</span>: wenn dies auf <span class="docutils literal">True</span> gesetzt wird, dann wird das Schließen
von Verbindungen erlaubt, normalerweise wird es jedoch ignoriert</p></li>
<li><p><span class="docutils literal">threadlocal</span>: eine optionale Klasse zur Speicherung thread-lokaler Daten,
die anstelle unserer Python-Implementierung benutzt wird (threading.local
ist schneller, kann aber nicht in allen Fällen verwendet werden)</p></li>
<li><p>Die als <span class="docutils literal">creator</span> angegebene Funktion oder die Funktion <span class="docutils literal">connect</span>
des DB-API-2-Datenbankadapter-Moduls erhalten alle weiteren Parameter,
wie <span class="docutils literal">host</span>, <span class="docutils literal">database</span>, <span class="docutils literal">user</span>, <span class="docutils literal">password</span> usw. Sie können einige
oder alle dieser Parameter in Ihrer eigenen <span class="docutils literal">creator</span>-Funktion setzen, was
ausgefeilte Mechanismen zur Ausfallsicherung und Lastverteilung ermöglicht.</p></li>
</ul>
<p>Wenn Sie beispielsweise <span class="docutils literal">pgdb</span> als DB-API-2-Datenbankadapter verwenden, und
möchten, dass jede Verbindung Ihrer lokalen Datenbank <span class="docutils literal">meinedb</span> 1000 mal
wiederverwendet werden soll, sieht die Initialisierung so aus:</p>
<pre class="literal-block">import pgdb  # importiere das verwendete DB-API-2-Modul
from dbutils.persistent_db import PersistentDB
persist = PersistentDB(pgdb, 1000, database='meinedb')</pre>
<p>Nachdem Sie den Generator mit diesen Parametern eingerichtet haben, können
Sie derartige Datenbankverbindungen von da an wie folgt anfordern:</p>
<pre class="literal-block">db = persist.connection()</pre>
<p>Sie können diese Verbindungen verwenden, als wären sie gewöhnliche
DB-API-2-Datenbankverbindungen. Genauer genommen erhalten Sie die
&quot;gehärtete&quot; <span class="docutils literal">steady_db</span>-Version der zugrunde liegenden DB-API-2-Verbindung.</p>
<p>Wenn Sie eine solche persistente Verbindung mit <span class="docutils literal">db.close()</span> schließen,
wird dies stillschweigend ignoriert, denn sie würde beim nächsten Zugriff
sowieso wieder geöffnet, und das wäre nicht im Sinne persistenter Verbindungen.
Stattdessen wird die Verbindung automatisch dann geschlossen, wenn der Thread
endet. Sie können dieses Verhalten ändern, indem Sie den Parameter namens
<span class="docutils literal">closeable</span> setzen.</p>
<p>Bitte beachten Sie, dass Transaktionen explizit durch Aufruf der Methode
<span class="docutils literal">begin()</span> eingeleitet werden müssen. Hierdurch wird sichergestellt, dass
das transparente Neueröffnen von Verbindungen bis zum Ende der Transaktion
ausgesetzt wird, und dass die Verbindung zurückgerollt wird, before sie vom
gleichen Thread erneut benutzt wird.</p>
<p>Das Holen einer Verbindung kann etwas beschleunigt werden, indem man den
Parameter <span class="docutils literal">threadlocal</span> auf <span class="docutils literal">threading.local</span> setzt; dies könnte aber in
einigen Umgebungen nicht funktionieren (es ist zum Beispiel bekannt, dass
<span class="docutils literal">mod_wsgi</span> hier Probleme bereitet, da es Daten, die mit <span class="docutils literal">threading.local</span>
gespeichert wurden, zwischen Requests löscht).</p>
</section>
<section id="pooleddb-pooled-db-1">
<h3>PooledDB (pooled_db)</h3>
<p>Wenn Sie das <span class="docutils literal">pooled_db</span>-Modul einsetzen möchten, müssen Sie zuerst einen
Pool für die von Ihnen gewünschte Art von Datenbankverbindungen einrichten,
indem Sie eine Instanz der Klasse <span class="docutils literal">pooled_db</span> erzeugen, wobei Sie folgende
Parameter angeben müssen:</p>
<ul>
<li><p><span class="docutils literal">creator</span>: entweder eine Funktion, die neue DB-API-2-Verbindungen
erzeugt, oder ein DB-API-2-Datenbankadapter-Modul</p></li>
<li><p><span class="docutils literal">mincached</span> : die anfängliche Anzahl inaktiver Verbindungen, die auf
Vorrat gehalten werden sollen (der Standardwert <span class="docutils literal">0</span> bedeutet, dass beim
Start keine Verbindungen geöffnet werden)</p></li>
<li><p><span class="docutils literal">maxcached</span>: Obergrenze für die Anzahl inaktiver Verbindungen, die auf
Vorrat gehalten werden sollen (der Standardwert <span class="docutils literal">0</span> oder <span class="docutils literal">None</span> bedeutet
unbegrenzte Größe des Vorratsspeichers)</p></li>
<li><p><span class="docutils literal">maxshared</span>: Obergrenze für die Anzahl gemeinsam genutzer Verbindungen
(der Standardwert <span class="docutils literal">0</span> oder <span class="docutils literal">None</span> bedeutet, dass alle Verbindungen
dediziert sind)</p>
<p>Wenn diese Obergrenze erreicht wird, werden Verbindungen wiederverwendet,
wenn diese als wiederverwendbar angefordert werden.</p>
</li>
<li><p><span class="docutils literal">maxconnections</span>: Obergrenze für die Anzahl an Datenbankverbindungen,
die insgesamt überhaupt erlaubt werden sollen (der Standardwert <span class="docutils literal">0</span>
oder <span class="docutils literal">None</span> bedeutet unbegrenzte Anzahl von Datenbankverbindungen)</p></li>
<li><p><span class="docutils literal">blocking</span>: bestimmt das Verhalten bei Überschreitung dieser Obergrenze</p>
<p>Wenn dies auf <span class="docutils literal">True</span> gesetzt wird, dann wird so lange gewartet, bis die
Anzahl an Datenbankverbindungen wieder abnimmt, normalerweise wird jedoch
sofort eine Fehlermeldung ausgegeben.</p>
</li>
<li><p><span class="docutils literal">maxusage</span>: Obergrenze dafür, wie oft eine einzelne Verbindung
wiederverwendet werden darf (der Standardwert <span class="docutils literal">0</span> oder <span class="docutils literal">None</span>
bedeutet unbegrenzte Wiederverwendung)</p>
<p>Sobald diese Obergrenze erreicht wird, wird die Verbindung automatisch
zurückgesetzt (geschlossen und wieder neu geöffnet).</p>
</li>
<li><p><span class="docutils literal">setsession</span>: eine optionale Liste von SQL-Befehlen zur Initialisierung
der Datenbanksitzung, z.B. <span class="docutils literal">[&quot;set datestyle to german&quot;, <span class="pre">...]</span></span></p></li>
<li><p><span class="docutils literal">reset</span>: wie Verbindungen zurückgesetzt werden sollen, bevor sie wieder
in den Verbindungspool zurückgegeben werden (<span class="docutils literal">False</span> oder <span class="docutils literal">None</span>
um mit <span class="docutils literal">begin()</span> gestartete Transaktionen zurückzurollen, der Standardwert
<span class="docutils literal">True</span> rollt sicherheitshalber mögliche Transaktionen immer zurück)</p></li>
<li><p><span class="docutils literal">failures</span>: eine optionale Exception-Klasse oder ein Tupel von Exceptions,
bei denen die Ausfallsicherung zum Tragen kommen soll, falls die Vorgabe
(OperationalError, InterfaceError, InternalError) für das verwendete
Datenbankadapter-Modul nicht geeignet sein sollte</p></li>
<li><p><span class="docutils literal">ping</span>: mit diesem Parameter kann eingestellt werden, wann Verbindungen
mit der <span class="docutils literal">ping()</span>-Methode geprüft werden, falls eine solche vorhanden ist
(<span class="docutils literal">0</span> = <span class="docutils literal">None</span> = nie, <span class="docutils literal">1</span> = Standardwert = immer wenn neu angefragt,
<span class="docutils literal">2</span> = vor Erzeugen eines Cursors, <span class="docutils literal">4</span> = vor dem Ausführen von Abfragen,
<span class="docutils literal">7</span> = immer, und alle Bitkombinationen dieser Werte)</p></li>
<li><p>Die als <span class="docutils literal">creator</span> angegebene Funktion oder die Funktion <span class="docutils literal">connect</span>
des DB-API-2-Datenbankadapter-Moduls erhalten alle weiteren Parameter,
wie <span class="docutils literal">host</span>, <span class="docutils literal">database</span>, <span class="docutils literal">user</span>, <span class="docutils literal">password</span> usw. Sie können einige
oder alle dieser Parameter in Ihrer eigenen <span class="docutils literal">creator</span>-Funktion setzen, was
ausgefeilte Mechanismen zur Ausfallsicherung und Lastverteilung ermöglicht.</p></li>
</ul>
<p>Wenn Sie beispielsweise <span class="docutils literal">pgdb</span> als DB-API-2-Datenbankadapter benutzen,
und einen Pool von mindestens fünf Datenbankverbindungen zu Ihrer Datenbank
<span class="docutils literal">meinedb</span> verwenden möchten, dann sieht die Initialisierung so aus:</p>
<pre class="literal-block">import pgdb  # importiere das verwendete DB-API-2-Modul
from dbutils.pooled_db import PooledDB
pool = PooledDB(pgdb, 5, database='meinedb')</pre>
<p>Nachdem Sie den Pool für Datenbankverbindungen so eingerichtet haben, können
Sie Verbindungen daraus wie folgt anfordern:</p>
<pre class="literal-block">db = pool.connection()</pre>
<p>Sie können diese Verbindungen verwenden, als wären sie gewöhnliche
DB-API-2-Datenbankverbindungen. Genauer genommen erhalten Sie die
&quot;gehärtete&quot; <span class="docutils literal">steady_db</span>-Version der zugrunde liegenden DB-API-2-Verbindung.</p>
<p>Bitte beachten Sie, dass die Verbindung von anderen Threads mitgenutzt werden
kann, wenn Sie den Parameter <span class="docutils literal">maxshared</span> auf einen Wert größer als Null
gesetzt haben, und der zugrunde liegende DB-API-2-Datenbankadapter dies erlaubt.
Eine dedizierte Datenbankverbindung, die garantiert nicht von anderen Threads
mitgenutzt wird, fordern Sie wie folgt an:</p>
<pre class="literal-block">db = pool.connection(shareable=False)</pre>
<p>Stattdessen können Sie eine dedizierte Verbindung auch wie folgt erhalten:</p>
<pre class="literal-block">db = pool.dedicated_connection()</pre>
<p>Wenn Sie die Datenbankverbindung nicht mehr benötigen, sollten Sie diese sofort
wieder mit <span class="docutils literal">db.close()</span> an den Pool zurückgeben. Sie können auf die gleiche
Weise eine neue Verbindung erhalten.</p>
<p><em>Warnung:</em> In einer Multithread-Umgebung benutzen Sie niemals:</p>
<pre class="literal-block">pool.connection().cursor().execute(...)</pre>
<p>Dies würde die Datenbankverbindung zu früh zur Wiederverwendung zurückgeben,
was fatale Folgen haben könnte, wenn die Verbindungen nicht thread-sicher sind.
Stellen Sie sicher, dass die Verbindungsobjekte so lange vorhanden sind, wie
sie gebraucht werden, etwa so:</p>
<pre class="literal-block">db = pool.connection()
cur = db.cursor()
cur.execute(...)
res = cur.fetchone()
cur.close()  # oder del cur
db.close()  # oder del db</pre>
<p>Sie können dies auch durch Verwendung von Kontext-Managern vereinfachen:</p>
<pre class="literal-block">with pool.connection() as db:
    with db.cursor() as cur:
        cur.execute(...)
        res = cur.fetchone()</pre>
<p>Bitte beachten Sie, dass Transaktionen explizit durch Aufruf der Methode
<span class="docutils literal">begin()</span> eingeleitet werden müssen. Hierdurch wird sichergestellt,
dass die Verbindung nicht mehr mit anderen Threads geteilt wird, dass das
transparente Neueröffnen von Verbindungen bis zum Ende der Transaktion
ausgesetzt wird, und dass die Verbindung zurückgerollt wird, bevor sie
wieder an den Verbindungspool zurückgegeben wird.</p>
</section>
</section>
<section id="besonderheiten-bei-der-benutzung">
<h2>Besonderheiten bei der Benutzung</h2>
<p>Manchmal möchte man Datenbankverbindung besonders vorbereiten, bevor sie
von DBUtils verwendet werden, und dies ist nicht immer durch Verwendung
der passenden Parameter möglich. Zum Beispiel kann es <span class="docutils literal">pyodb</span> erfordern,
dass man die Methode <span class="docutils literal">setencoding()</span> der Datenbankverbindung aufruft.
Sie können dies erreichen, indem Sie eine modifizierte Version der
Funktion <span class="docutils literal">connect()</span> verwenden und diese als <span class="docutils literal">creator</span> (dem ersten
Argument) an <span class="docutils literal">PersistentDB</span> oder <span class="docutils literal">PooledDB</span> übergeben, etwa so:</p>
<pre class="literal-block">from pyodbc import connect
from dbutils.pooled_db import PooledDB

def creator():
    con = connect(...)
    con.setdecoding(...)
    return con

creator.dbapi = pyodbc

db_pool = PooledDB(creator, mincached=5)</pre>
</section>
<section id="anmerkungen">
<h2>Anmerkungen</h2>
<p>Wenn Sie einen der bekannten &quot;Object-Relational Mapper&quot; <a class="reference external" href="http://sqlobject.org/">SQLObject</a> oder
<a class="reference external" href="https://www.sqlalchemy.org">SQLAlchemy</a> verwenden, dann benötigen Sie DBUtils nicht, denn diese haben
ihre eigenen Mechanismen zum Pooling von Datenbankverbindungen eingebaut.
Tatsächlich hat SQLObject 2 (SQL-API) das Pooling in eine separate Schicht
ausgelagert, in der Code von DBUtils verwendet wird.</p>
<p>Wenn Sie eine Lösung verwenden wie den Apache-Webserver mit <a class="reference external" href="http://modpython.org/">mod_python</a>
oder <a class="reference external" href="https://github.com/GrahamDumpleton/mod_wsgi">mod_wsgi</a>, dann sollten Sie bedenken, dass Ihr Python-Code normalerweise
im Kontext der Kindprozesse des Webservers läuft. Wenn Sie also das
<span class="docutils literal">pooled_db</span>-Modul einsetzen, und mehrere dieser Kindprozesse laufen, dann
werden Sie ebenso viele Pools mit Datenbankverbindungen erhalten. Wenn diese
Prozesse viele Threads laufen lassen,  dann mag dies eine sinnvoller Ansatz
sein, wenn aber diese Prozesse nicht mehr als einen Worker-Thread starten,
wie im Fall des Multi-Processing Moduls &quot;prefork&quot; für den Apache-Webserver,
dann sollten Sie auf eine Middleware für das Connection-Pooling zurückgreifen,
die Multi-Processing unterstützt, wie zum Beispiel <a class="reference external" href="https://www.pgpool.net/">pgpool</a> oder <a class="reference external" href="https://pgbouncer.github.io/">pgbouncer</a>
für die PostgreSQL-Datenbank.</p>
</section>
<section id="zukunft">
<h2>Zukunft</h2>
<p>Einige Ideen für zukünftige Verbesserungen:</p>
<ul class="simple">
<li><p>Alternativ zur Obergrenze in der Anzahl der Nutzung einer Datenbankverbindung
könnte eine maximale Lebensdauer für die Verbindung implementiert werden.</p></li>
<li><p>Es könnten Module <span class="docutils literal">monitor_db</span> und <span class="docutils literal">monitor_pg</span> hinzugefügt werden, die
in einem separaten Thread ständig den &quot;idle pool&quot; und eventuell auch den
&quot;shared pool&quot; bzw. die persistenten Verbindungen überwachen. Wenn eine
unterbrochene Datenbankverbindung entdeckt wird, wird diese automatisch durch
den Monitor-Thread wiederhergestellt. Dies ist in einem Szenario sinnvoll,
bei dem die Datenbank einer Website jede Nacht neu gestartet wird. Ohne
den Monitor-Thread würden die Benutzer morgens eine kleine Verzögerung
bemerken, weil erst dann die unterbrochenen Datenbankverbindungen entdeckt
würden und sich der Pool langsam wieder neu aufbaut. Mit dem Monitor-Thread
würde dies schon während der Nacht passieren, kurz nach der Unterbrechung.
Der Monitor-Thread könnte auch so konfiguriert werden, dass er überhaupt
täglich den Verbindungspool erneuert, kurz bevor die Benutzer erscheinen.</p></li>
<li><p>Optional sollten Benutzung, schlechte Verbindungen und Überschreitung von
Obergrenzen in Logs gespeichert werden können.</p></li>
</ul>
</section>
<section id="fehlermeldungen-und-feedback">
<h2>Fehlermeldungen und Feedback</h2>
<p>Fehlermeldungen, Patches und Feedback können Sie als <a class="reference external" href="https://github.com/WebwareForPython/DBUtils/issues">Issues</a> oder
<a class="reference external" href="https://github.com/WebwareForPython/DBUtils/pulls">Pull Requests</a> auf der <a class="reference external" href="https://github.com/WebwareForPython/DBUtils">GitHub-Projektseite</a> von DBUtils übermitteln.</p>
</section>
<section id="links">
<h2>Links</h2>
<p>Einige Links zu verwandter und alternativer Software:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/WebwareForPython/DBUtils">DBUtils</a></p></li>
<li><p><a class="reference external" href="https://www.python.org">Python</a></p></li>
<li><p><a class="reference external" href="https://webwareforpython.github.io/w4py/">Webware for Python</a> Framework</p></li>
<li><p>Python <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">DB-API 2</a></p></li>
<li><p><a class="reference external" href="https://www.postgresql.org/">PostgreSQL</a> Datenbank</p></li>
<li><p><a class="reference external" href="https://www.pygresql.org/">PyGreSQL</a> Python-Adapter for PostgreSQL</p></li>
<li><p><a class="reference external" href="https://www.pgpool.net/">pgpool</a> Middleware für Connection-Pooling mit PostgreSQL</p></li>
<li><p><a class="reference external" href="https://pgbouncer.github.io/">pgbouncer</a> Middleware für Connection-Pooling mit PostgreSQL</p></li>
<li><p><a class="reference external" href="http://sqlobject.org/">SQLObject</a> Objekt-relationaler Mapper</p></li>
<li><p><a class="reference external" href="https://www.sqlalchemy.org">SQLAlchemy</a> Objekt-relationaler Mapper</p></li>
</ul>
</section>
<section id="autoren">
<h2>Autoren</h2>
<dl class="field-list simple">
<dt>Autor<span class="colon">:</span></dt>
<dd><p><a class="reference external" href="https://github.com/Cito">Christoph Zwerschke</a></p>
</dd>
<dt>Beiträge<span class="colon">:</span></dt>
<dd><p>DBUtils benutzt Code, Anmerkungen und Vorschläge von
Ian Bicking, Chuck Esterbrook (Webware for Python), Dan Green (DBTools),
Jay Love, Michael Palmer, Tom Schwaller, Geoffrey Talvola,
Warren Smith (DbConnectionPool), Ezio Vernacotola, Jehiah Czebotar,
Matthew Harriger, Gregory Piñero und Josef van Eenbergen.</p>
</dd>
</dl>
</section>
<section id="copyright-und-lizenz">
<h2>Copyright und Lizenz</h2>
<p>Copyright © 2005-2023 Christoph Zwerschke.
Alle Rechte vorbehalten.</p>
<p>DBUtils ist freie und quelloffene Software,
lizenziert unter der <a class="reference external" href="https://opensource.org/licenses/MIT">MIT-Lizenz</a>.</p>
</section>
</main>
</body>
</html>
